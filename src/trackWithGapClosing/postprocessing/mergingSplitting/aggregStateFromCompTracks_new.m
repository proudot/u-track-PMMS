function [compTracksOut,segmentStat] = aggregStateFromCompTracks_new(compTracks,intensityInfo)
%AGGREGSTATEFROMCOMPTRACKS recovers particle aggregation states from compound tracks
%
%SYNOPSIS compTracks = aggregStateFromCompTracks(compTracks,intensityInfo)
%
%INPUT  compTracks   : Compound tracks, in the format of tracksFinal as
%                      output by trackCloseGapsKalman.
%       intensityInfo: Row vector with unit intensity mean and standard
%                      deviation (e.g. the intensity of a single
%                      fluorophore labeling a single receptor).
%
%OUTPUT compTracks   : -Structure with the 2 fields "defaultFormatTracks" and
%                       "alternativeFormatTracks". 
%                      -Both contain the fields "tracksFeatIndxCG",
%                       "tracksCoordAmpCG", "seqOfEvents" and "aggregState".
%                      -"alternativeFormatTracks" also contains the field
%                       "alt2defSegmentCorrespond".
%                      -"defaultFormatTracks" is the format of the output of
%                       "trackCloseGapsKalman". 
%                      -"alternativeFormatTracks" is the format generated by
%                       the function "convFormatDefault2Alt", where tracks
%                       do not continue through merges and splits, but a
%                       merge consists of 2 track segments mergng to form a
%                       3rd segment, and a split consists of 1 track segment
%                       splitting into 2 different segments. 
%                      -The field "aggregState" has the same dimensions as
%                       "tracksFeatIndxCG", and indicates the estimated
%                       number of units (e.g. receptors) within each
%                       detected particle/feature.
%
%       segmentStat:    a struct with with the following fields detailing
%                       segment stats and size errors:
%                       1) intSizeErr:  IDs of segments with intensity size
%                       errors
%                       2) eveSizeErr:  IDs of segments with size errors as
%                       determined from events
%                       3) notRepIntSizeErr:  indicates segments whose
%                       intensity size errors were not repaired, when
%                       repairing - [] here.
%                       4) finalNotRepIntSizeErr:  final list of segments 
%                       whose intensity size errors were not repaired, when
%                       repairing - [] here.
%                       5) notRepEveSizeErr:  indicates segments whose
%                       event size errors were not repaired, when
%                       repairing - [] here.
%                       6) numInitSegs: number of initial segments
%                       7) numInitSegs: total number of segments
%                       8) numSplits: total number of split events
%                       9) numMerges: total number of merge events
%
%
%Khuloud Jaqaman, February 2009
%       Modified, January 2013, Robel Yirdaw
%       Modified, 12/12/14, Robel Yirdaw


%% Input

%assign default intensityInfo if not input
if nargin < 2 || isempty(intensityInfo)
    intensityInfo = [];
else
    %if unit intensity is input, construct vector of integer multiples of
    %mean unit intensity
    multUnitAmp = intensityInfo(1)*(1:100)';
end

%get number of compound tracks
numTracks = length(compTracks);

%convert tracks from default format (output of trackCloseGapsKalman) to
%alternative format where there is no track continuation through a merge or
%a split
compTracksDef = compTracks;
fprintf('\nIn aggregState...entering convTrackFormatDefault2Alt...');
convDef2AltTic = tic;
compTracks = convTrackFormatDefault2Alt(compTracksDef);
convDef2AltTime = toc(convDef2AltTic);
fprintf('\nDone with convTrackFormatDefault2Alt. Elapsed time is %g seconds.\n',convDef2AltTime);

%Initialize segmentStat described above.
segmentStat(numTracks,1) = struct('intSizeErr','','eveSizeErr','','notRepIntSizeErr','',...
    'finalNotRepIntSizeErr','','notRepEveSizeErr','','numInitSegs','','numSegs','',...
    'numSplits','','numMerges','');


%% Calculation

%go over all compound tracks
for iTrack = 1 : numTracks
    
    fprintf('\nIn aggregState...at iTrack %d',iTrack);
    
    %get this compound track's information
    seqOfEvents = compTracks(iTrack).seqOfEvents;
    tracksFeatIndx = compTracks(iTrack).tracksFeatIndxCG;
    tracksAmp = compTracks(iTrack).tracksCoordAmpCG(:,4:8:end);
    
    %     %if requested, remove splits and merges that are most likely artifacts
    %     removePotArtifacts = 0;
    %     if removePotArtifacts
    %         seqOfEvents = removeSplitMergeArtifacts(seqOfEvents,0);
    %     end

    %determine whether track is sampled regularly or with doubled frequency
    doubleFreq = mod(seqOfEvents(1,1)*2,2)==1;

    %shift time in seqOfEvents to make the track start at frame 1 or 0.5
    %if sampling frequency is doubled
    seqOfEvents(:,1) = seqOfEvents(:,1) - seqOfEvents(1,1) + 1/(1+doubleFreq);

    %find all merging and splitting events
    msEvents = find(~isnan(seqOfEvents(:,4)));
    numMSEvents = length(msEvents);

    %initialize matrix storing aggregation state
    %     if isempty(intensityInfo) %if no information is given on the unit intensity
    %082114 - tracksFeatIndx must be converted to full if sparse. If not,
    %the function will hang on lines 113-114.
    aggregStateMat = full(tracksFeatIndx); %initialize every branch with 1 unit
    aggregStateMat = double((aggregStateMat ~= 0));
    aggregStateMat(aggregStateMat==0) = NaN;
    %     else %if there is unit intensity information
    %
    %     end

    %if this track does not exhibit any merges or splits, and there is unit
    %intensity information ...
    if numMSEvents == 0 && ~isempty(intensityInfo)
        
        %get this track's average intensity
        %meanAmp = nanmean(tracksAmp);
        %082514 - replaced the original nanmean with mean since
        %tracksCoordAmpCG is now in sparse format. Should also handle
        %non-sparse tracksCoordAmpCG if necessary (NaNs present).
        meanAmp = mean( tracksAmp(:,(~isnan(tracksAmp) & (tracksAmp ~= 0))) );
        
        %subtract the integer multiples of the unit intensity from the
        %track's mean intensity
        meanAmpMinusMultUnitAmp = abs(meanAmp - multUnitAmp);
        
        %determine integer multiple yielding smallest difference
        intMult = find(meanAmpMinusMultUnitAmp==min(meanAmpMinusMultUnitAmp));
        
        %assign this value to the aggregation state of this track
        aggregStateMat = aggregStateMat * intMult;
        
    end %(if numMSEvents == 0)
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    if (numMSEvents ~= 0)
        
        numSegments = length(tracksAmp(:,1));
        segmentSet = NaN(numSegments,10);
        segmentSet(:,9) = 1;
        %Save segments with error in intentsity and event sizes
        segmentErr = {NaN(numSegments,1) NaN(numSegments,2)};

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %112014
        %Modified to now determine initSegs a segment that is created at
        %any point during the simulation/data acquistion time, instead of
        %segments present ONLY at frame 1.  This is done to accomodate
        %experimental data which can have segments appear anytime during
        %data acquisition.
        %initSegs = seqOfEvents(((seqOfEvents(:,1) == 1) & isnan(seqOfEvents(:,4))),3);
        initSegs = seqOfEvents(((seqOfEvents(:,2) == 1) & isnan(seqOfEvents(:,4))),3);
        numInitSegs = length(initSegs);   
        
        numSplitEvents = sum(~isnan(seqOfEvents(:,4)) & (seqOfEvents(:,2) == 1))/2;
        numMergeEvents = sum(~isnan(seqOfEvents(:,4)) & (seqOfEvents(:,2) == 2))/2;
        
        fprintf('\nNumber of starting segments is %d.',numInitSegs);
        fprintf('\nNumber of events is %d (%d splits, %d merges).',numMSEvents/2,...
            numSplitEvents,numMergeEvents);
        fprintf('\nNumber of segments is %d.',numSegments);        

        %fprintf('\n\nContinue...\n');
        %pause;
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %Begin processing segments
        %102313        
        %Track number of recurssive calls
        callCount = 1;
        processSegEveTic = tic();
        for initSegsIter=1:numInitSegs
            [segmentSet,segmentErr,callCount] = processSegmentEvents(NaN,initSegs(initSegsIter),...
                segmentSet,segmentErr,seqOfEvents,tracksAmp,intensityInfo,callCount);
        end
        processSegEveETime = toc(processSegEveTic);
        fprintf('\n============\nTime for processSegmentEvents is %g seconds. \n============\n',processSegEveETime);
        %Number of segments with size errors
        segIntSizeErrCount = sum(~isnan(segmentErr{1}));
        %Trim NaNs
        segmentErr{1}(segIntSizeErrCount+1:end) = [];  
        fprintf('\n');
        %}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %Correct segments identified to have intensity amplitude errors via
        %repairSizeFromIntensity.
        fprintf('\n=====================================================================');
        segmentSet_rev1 = segmentSet;

        %Will collect information on segments whose intensity based sizes
        %were not repaired. The 5 elements in the cell are as follows:
        % 1) ID of segment not repaired
        % 2) a cell with a string indicating error case type
        % 3) a cell with a string stating the repair outcome
        % 4) a cell with a string for the event type, either a split or merge
        % 5) the amount of discrepancy, calculated based on the type of event        
        notRepIntSizeErr = {NaN(segIntSizeErrCount,1) cell(segIntSizeErrCount,1)...
                cell(segIntSizeErrCount,1) cell(segIntSizeErrCount,1) ...
                NaN(segIntSizeErrCount,1)};
        finalNotRepIntSizeErr = [];
        if (segIntSizeErrCount > 0)
            fprintf('\nFound %d intensity size errors. Repairing.',segIntSizeErrCount);
            %segmentErr{1}(segIntSizeErrCount+1:end) = [];        
            %for errIter=segIntAmpErrCount:-1:1
            
            try
                for errIter=1:segIntSizeErrCount
                    fprintf('\n==>%d. Passing seg. %d.',errIter,segmentErr{1}(errIter));                
                    [segmentSet_rev1,notRepIntSizeErr] = repairSizeFromIntensity(segmentErr{1}(errIter),...
                        segmentSet_rev1,0,notRepIntSizeErr,intensityInfo); 
                end
            catch exc_repairSizeFromIntensit
                fprintf('\n=============================================');
                fprintf('\nCatch: \n %s',exc_repairSizeFromIntensit.message);
                exc_repairSizeFromIntensit.stack(1)
                fprintf('=============================================');
                %pause;
                return;
            end
            
            %Trim not repaired list
            numNotRepIntSizeErr = sum(~isnan(notRepIntSizeErr{1}));
            notRepIntSizeErr{1}(numNotRepIntSizeErr+1:end) = [];
            notRepIntSizeErr{2}(numNotRepIntSizeErr+1:end) = [];
            notRepIntSizeErr{3}(numNotRepIntSizeErr+1:end) = [];
            notRepIntSizeErr{4}(numNotRepIntSizeErr+1:end) = [];
            notRepIntSizeErr{5}(numNotRepIntSizeErr+1:end) = [];

            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %Begin check on repairs by looking through final not repaired
            %list.
            fprintf('\n\nChecking repairs on intensity size errors.');
            fprintf('\nNumber of segments not repaired is %d.',numNotRepIntSizeErr);            
            %Copy error info
            if (numNotRepIntSizeErr > 0)
                finalNotRepIntSizeErr = notRepIntSizeErr;
                initSegsIter = 1;
                while ( initSegsIter <= numel(finalNotRepIntSizeErr{1}(:,1)) )
                    currNotRepSegID = finalNotRepIntSizeErr{1}(initSegsIter,1);
                    %Default is split (1).
                    fprintf('\n==>Checking segment %d. ',currNotRepSegID);
                    
                    if (strcmp(finalNotRepIntSizeErr{4}(initSegsIter),'split'))
                        eventType = 1;
                        selfChk = (segmentSet_rev1(currNotRepSegID,8) ==...
                            segmentSet_rev1(segmentSet_rev1(currNotRepSegID,3),8) +...
                            segmentSet_rev1(segmentSet_rev1(currNotRepSegID,4),8) );
                    else
                        eventType = 2;
                        selfChk = (segmentSet_rev1(currNotRepSegID,8) +...
                            segmentSet_rev1(segmentSet_rev1(currNotRepSegID,6),8) ==...
                            segmentSet_rev1(segmentSet_rev1(currNotRepSegID,3),8) );
                    end
                    
                    bwdChk = checkSegmentSize(currNotRepSegID,segmentSet_rev1,-1,1,0);
                    fwdChk = checkSegmentSize(currNotRepSegID,segmentSet_rev1,1,1,0);
                    if ( (selfChk == 1) && (bwdChk == 1) && (fwdChk == 1))
                        %Repair ok. Remove segment from list.
                        fprintf('Repaired. ');
                        finalNotRepIntSizeErr{1}(initSegsIter,:) = [];
                        finalNotRepIntSizeErr{2}(initSegsIter) = [];
                        finalNotRepIntSizeErr{3}(initSegsIter) = [];
                        finalNotRepIntSizeErr{4}(initSegsIter) = [];
                        finalNotRepIntSizeErr{5}(initSegsIter) = [];
                    else
                        fprintf('Not repaired. ');

                        eventRows = find((seqOfEvents(:,2) == eventType) & ...
                            ((seqOfEvents(:,3) == currNotRepSegID) |...
                             (seqOfEvents(:,4) == currNotRepSegID) ) );                        
                        finalNotRepIntSizeErr{1}(initSegsIter,2) =...
                            seqOfEvents(eventRows(1),1);
                        
                        initSegsIter = initSegsIter + 1;
                    end
                end
            end

            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %Recheck all. During the repair there is the possibility that
            %updating a given segment's size to repair its event affects
            %the subsequent or prior events that *did not have size errors*
            %Such cases are a very small minority. For instance, a run with
            %assocProb=1, dissocRate=1, intensit quantum=[1 0.3] can give
            %size errors around 3000, of which only ~30 will be left
            %unrepaired and the cases being considered here would be ~ 5.
            
            %Split events.
            splitEveIndx = find(~isnan(segmentSet_rev1(:,3)) & ~isnan(segmentSet_rev1(:,4)));
            splitEveSizes_B = [segmentSet_rev1(splitEveIndx,8)...
                segmentSet_rev1(segmentSet_rev1(splitEveIndx,3),8) + ...
                segmentSet_rev1(segmentSet_rev1(splitEveIndx,4),8)];
            splitEveErrIndx_B = splitEveIndx((splitEveSizes_B(:,1) ~= splitEveSizes_B(:,2)) |...
                segmentSet_rev1(splitEveIndx,8) == 0 |...
                segmentSet_rev1(segmentSet_rev1(splitEveIndx,3),8) == 0 |...
                segmentSet_rev1(segmentSet_rev1(splitEveIndx,4),8) == 0 |...
                (segmentSet_rev1(segmentSet_rev1(splitEveIndx,3),8) > 1 &...
                segmentSet_rev1(segmentSet_rev1(splitEveIndx,4),8) > 1) );
            %Merge events.
            mergeEveIndx = find(~isnan(segmentSet_rev1(:,3)) & isnan(segmentSet_rev1(:,4)) &...
                ~isnan(segmentSet_rev1(:,6)));
            mergeEveParent2ID = segmentSet_rev1(mergeEveIndx,6);
            mergeEveIndxP1 = mergeEveIndx;
            %Remove duplicates
            mergeEveIndxP1(mergeEveIndxP1 > mergeEveParent2ID) = [];
            
            mergeEveSizes_B = [segmentSet_rev1(mergeEveIndxP1,8) + ...
                segmentSet_rev1(segmentSet_rev1(mergeEveIndxP1,6),8) ...
                segmentSet_rev1(segmentSet_rev1(mergeEveIndxP1,3),8)];
            mergeEveErrIndxP1_B = mergeEveIndxP1(mergeEveSizes_B(:,1) ~= mergeEveSizes_B(:,2) | ...
                segmentSet_rev1(mergeEveIndxP1,8) == 0 |...
                segmentSet_rev1(segmentSet_rev1(mergeEveIndxP1,6),8) == 0 | ...
                segmentSet_rev1(segmentSet_rev1(mergeEveIndxP1,3),8) == 0 |...
                (segmentSet_rev1(mergeEveIndxP1,8) > 1 & ...
                segmentSet_rev1(segmentSet_rev1(mergeEveIndxP1,6),8) > 1) );
            
            %mergeEveErrIndxP2_B = segmentSet_rev1(mergeEveErrIndxP1_B,6);
            
            %Final number not repaired
            numNotRepFinal = 0;
            if (~isempty(finalNotRepIntSizeErr))
                numNotRepFinal = length(finalNotRepIntSizeErr{1});
            end
            
            fprintf('\nTotal not repaired: ');    
            fprintf('\n   finalNotRepaired = %d, ',numNotRepFinal);
            fprintf('\n   all = %d, ',length(splitEveErrIndx_B)+length(mergeEveErrIndxP1_B));
            
            notInSplit = [];            
            notInMerge_P2 = [];            
            notInSplitALL = [];            
            notInMergeALL_P2 = [];                        
            if (numNotRepFinal > 0)
                notInSplit = setdiff(splitEveErrIndx_B,finalNotRepIntSizeErr{1}(:,1));
                notInMerge_P1 = setdiff(mergeEveErrIndxP1_B,finalNotRepIntSizeErr{1}(:,1));

                if (~isempty(notInMerge_P1))
                    tempP2 = segmentSet(notInMerge_P1,6);
                    notInMerge_P2 = setdiff(tempP2,finalNotRepIntSizeErr{1}(:,1));            
                end

                notInSplitALL = setdiff(splitEveErrIndx_B,segmentErr{1});
                notInMergeALL_P1 = setdiff(mergeEveErrIndxP1_B,segmentErr{1});
                notInMergeALL_P2 = [];
                if (~isempty(notInMergeALL_P1))
                    tempP2 = segmentSet(notInMergeALL_P1,6);
                    notInMergeALL_P2 = setdiff(tempP2,segmentErr{1});            
                end               
            end
            fprintf('\n   diff = %d.',length([notInSplit;notInMerge_P2]));

                
            %Update finalNotRepIntSizeErr with seg. ids of those not found
            %in the original set.
            if (~isempty(notInSplit))
                startIndx = numNotRepFinal;
                for tempIndx=1:length(notInSplit)
                    finalNotRepIntSizeErr{1}(startIndx+tempIndx,1) = notInSplit(tempIndx);
                    finalNotRepIntSizeErr{2}{startIndx+tempIndx,1} = 'NaN';
                    finalNotRepIntSizeErr{3}{startIndx+tempIndx,1} = 'Repair updated';
                    finalNotRepIntSizeErr{4}{startIndx+tempIndx,1} = 'split';
                    finalNotRepIntSizeErr{5}(startIndx+tempIndx,1) = ...
                        splitEveSizes_B(splitEveIndx == notInSplit(tempIndx),1) - ...
                        splitEveSizes_B(splitEveIndx == notInSplit(tempIndx),2);
                end
            end
            if (~isempty(notInMerge_P2))
                startIndx = length(finalNotRepIntSizeErr{1});
                for tempIndx=1:length(notInMerge_P2)
                    finalNotRepIntSizeErr{1}(startIndx+tempIndx,1) = notInMerge_P2(tempIndx);
                    finalNotRepIntSizeErr{2}{startIndx+tempIndx,1} = 'NaN';
                    finalNotRepIntSizeErr{3}{startIndx+tempIndx,1} = 'Repair updated';
                    finalNotRepIntSizeErr{4}{startIndx+tempIndx,1} = 'merge';
                    finalNotRepIntSizeErr{5}(startIndx+tempIndx,1) = ...
                        segmentSet_rev1(notInMerge_P2(tempIndx),8) + ...
                        segmentSet_rev1(segmentSet_rev1(notInMerge_P2(tempIndx),6),8) -...
                        segmentSet_rev1(segmentSet_rev1(notInMerge_P2(tempIndx),3),8);
                end
            end
            if (~isempty(notInSplitALL))
                startIndx = length(finalNotRepIntSizeErr{1});
                for tempIndx=1:length(notInSplitALL)
                    finalNotRepIntSizeErr{1}(startIndx+tempIndx,1) = notInSplitALL(tempIndx);
                    finalNotRepIntSizeErr{2}{startIndx+tempIndx,1} = 'NaN';
                    finalNotRepIntSizeErr{3}{startIndx+tempIndx,1} = 'New';
                    finalNotRepIntSizeErr{4}{startIndx+tempIndx,1} = 'split';
                    finalNotRepIntSizeErr{5}(startIndx+tempIndx,1) = ...
                        splitEveSizes_B(splitEveIndx == notInSplitALL(tempIndx),1) - ...
                        splitEveSizes_B(splitEveIndx == notInSplitALL(tempIndx),2);
                end
            end
            if (~isempty(notInMergeALL_P2))
                startIndx = length(finalNotRepIntSizeErr{1});
                for tempIndx=1:length(notInMergeALL_P2)
                    finalNotRepIntSizeErr{1}(startIndx+tempIndx,1) = notInMergeALL_P2(tempIndx);
                    finalNotRepIntSizeErr{2}{startIndx+tempIndx,1} = 'NaN';
                    finalNotRepIntSizeErr{3}{startIndx+tempIndx,1} = 'New';
                    finalNotRepIntSizeErr{4}{startIndx+tempIndx,1} = 'merge';
                    finalNotRepIntSizeErr{5}(startIndx+tempIndx,1) = ...
                        segmentSet_rev1(notInMergeALL_P2(tempIndx),8) + ...
                        segmentSet_rev1(segmentSet_rev1(notInMergeALL_P2(tempIndx),6),8) -...
                        segmentSet_rev1(segmentSet_rev1(notInMergeALL_P2(tempIndx),3),8);
                end
            end                                                    
                
            %Check all, starting with initial segments
            %{
            fprintf('\nNumber of initial segments is %d.',numInitSegs);            
            for initSegsIter=1:numInitSegs
                fprintf('\n==>Checking initial segment %d.',initSegs(initSegsIter));
                checkSegmentSize(initSegs(initSegsIter),segmentSet_rev1,1,1,1);                        
            end
            %}
            
            fprintf('\nDone checking intensity sizes.');
        else
            fprintf('\nNo intensity size errors found.');
            segmentErr{1} = [];
        end%if intensity errors exist
        fprintf('\n=====================================================================');
        %fprintf('\n\nContinue...\n');
        %pause;
        
        %090414 - added for the commented out block below, since needed for
        %fields in segmentStat. Remove if enabling block below.
        segmentSet_rev2 = segmentSet_rev1;
        notRepEveSizeErr = [];
        
        %{
        %Segment sizes from events are not being used. To use these, enable
        the blocks below.
        
        fprintf('\n=====================================================================');
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %Correct segments identified to have errors in amplitudes from events
        segEveSizeErrCount = sum(~isnan(segmentErr{2}(:,1)));
        segmentSet_rev2 = segmentSet_rev1;
        notRepEveSizeErr = {NaN(segEveSizeErrCount,1) NaN(segEveSizeErrCount,1)...
                cell(segIntSizeErrCount,1)};
        if (segEveSizeErrCount > 0)
            fprintf('\nFound %d event size errors. Repairing.',segEveSizeErrCount);
            segmentErr{2}(segEveSizeErrCount+1:end,:) = [];
            %Segment IDs are in descending order. Start with lowest.
            for errIter=1:segEveSizeErrCount
                tempSegID = segmentErr{2}(errIter,1);
                segmentErr{2}(errIter,2) = max(segmentSet(tempSegID,9),...
                    segmentSet(segmentSet(tempSegID,3),9) + segmentSet(segmentSet(tempSegID,4),9));
            end
            %Sort in descending order of current sizes
            segmentErr{2} = sortrows(segmentErr{2},-2);
            %Process starting with the segment that has the largest size        
            for errIter=1:segEveSizeErrCount
                [segmentSet_rev2,notRepEveSizeErr] = repairSizeFromEvents(segmentErr{2}(errIter,1),...
                    segmentSet_rev2,0,notRepEveSizeErr);            
            end
            %Trim not repaired list
            numNotRepEveSizeErr = sum(~isnan(notRepEveSizeErr{1}));
            notRepEveSizeErr{1}(numNotRepEveSizeErr+1:end) = [];
            notRepEveSizeErr{2}(numNotRepEveSizeErr+1:end) = [];
            notRepEveSizeErr{3}(numNotRepEveSizeErr+1:end) = [];        

            fprintf('\nChecking repairs on event size errors.');
            fprintf('\nNumber of initial segments is %d.',numInitSegs);            
            for initSegsIter=1:numInitSegs
                fprintf('\n==>Checking initial segment %d.',initSegs(initSegsIter));
                checkSegmentSize(initSegs(initSegsIter),segmentSet_rev2,1,2,1);                        
            end
            fprintf('\nDone checking event sizes.');
        else
            fprintf('\nNo event size errors found.');
            segmentErr{2} = [];
        end%if intensity errors exist
        fprintf('\n=====================================================================');

        %}
        
        %fprintf('\n');
        %fprintf('\n\nContinue...\n');
        %pause;

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
        %For each segment, write final values to aggregStateMat.
        %aggregState is initialized with 1s and NaNs. To simplify writing
        %of final values, find those segments whose sizes are > 1 and just
        %update those.
        segmentsWithSizeGT1 = find(segmentSet_rev2(:,8) > 1);   
        
        %090414 - commented out since event size correction commented
        %out above.                    
        %numEventSizeLarger = 0;
        
        for segIter=1:(length(segmentsWithSizeGT1))
            tempSegID = segmentsWithSizeGT1(segIter);
            aggregStateMat(tempSegID,~isnan(aggregStateMat(tempSegID,:))) = ...
                segmentSet_rev2(tempSegID,8);
            %{
            %090414 - commented out since event size correction commented
            %out above.            
            if ((segmentSet_rev2(tempSegID,9) > segmentSet_rev2(tempSegID,8)) )
                fprintf('\nEvent size > intensity size for segment %d. ',...
                    tempSegID);
                numEventSizeLarger = numEventSizeLarger + 1;
            end
            %}
        end
        %{
        %090414 - commented out since event size correction commented
        %out above.                    
        if (numEventSizeLarger == 0)
            fprintf('\nAll event sizes <= intensity sizes.');
        end
        %}
        
        fprintf('\n');
        %fprintf('\n\nContinue...\n');
        %pause;
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %After construction, view and compare amplitudes from intensity and
        %events.    
        %{
        if (numSegments < 200)
            fprintf('\nDrawing %d segments.\n',numSegments);
            nodeIDs = cell(numSegments,1);
            for segIter=1:numSegments
                nodeIDs{segIter} = sprintf('Seg. %d, Sizes (%d:%d), (%d:%d) %g',segIter,segmentSet(segIter,8),...
                    segmentSet_rev1(segIter,8),segmentSet(segIter,9),segmentSet_rev2(segIter,9),...
                    segmentSet(segIter,7));
            end      
            %figure('name','Amplitude from intensity,events');
            [~,bgh] = bioGraphPlot_MergeSplitEvents(seqOfEvents,nodeIDs);
            set(bgh.Nodes,'Color',[.5 .9 1]);
            if (segIntSizeErrCount > 0)
                set(bgh.Nodes(([segmentErr{:,1}])),'Color',[0.9 0.3 0.6]);
            end
            if (segEveSizeErrCount > 0)
                set(bgh.Nodes([segmentErr{:,2}]),'Color',[0.5 0.5 0.8]);
                set(bgh.Nodes(intersect([segmentErr{:,1}],[segmentErr{:,2}])),...
                    'LineColor',[1 0 0],'LineWidth',2);
            end
        end
        %}

        %Prep return variable   
        segmentStat(iTrack).intSizeErr = segmentErr{1}(:);
        segmentStat(iTrack).eveSizeErr = segmentErr{2}(:);
        segmentStat(iTrack).notRepIntSizeErr = notRepIntSizeErr;
        segmentStat(iTrack).finalNotRepIntSizeErr = finalNotRepIntSizeErr;
        segmentStat(iTrack).notRepEveSizeErr = notRepEveSizeErr;
        segmentStat(iTrack).numInitSegs = numInitSegs;
        segmentStat(iTrack).numSegs = numSegments;
        segmentStat(iTrack).numSplits = numSplitEvents;
        segmentStat(iTrack).numMerges = numMergeEvents;
      
    end %numMSEvents ~= 0
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %store aggregation state matrix in compound tracks structure with
    %"alternative format"
    %Blocked 082114 - moved below
    %compTracks(iTrack).aggregState = aggregStateMat;

    %store aggregation state matrix in compound tracks structure with
    %"default format" ...

    %get number of segments in default format
    numSegmentsDef = size(compTracksDef(iTrack).tracksFeatIndxCG,1);

    %copy aggregation state matrix
    aggregStateDef = aggregStateMat(1:numSegmentsDef,:);

    %copy out segment correspondence array
    segmentCorrespond = compTracks(iTrack).alt2defSegmentCorrespond;

    %go over additional segments in alternative format and store their
    %aggregation state in the original segment location
    for iSegment = 1 : size(segmentCorrespond,1)
        segmentNew = segmentCorrespond(iSegment,1);
        segmentOld = segmentCorrespond(iSegment,2);
        aggregStateDef(segmentOld,:) = max([aggregStateDef(segmentOld,:);...
            aggregStateMat(segmentNew,:)]);
    end
    
    %Moved from above with conversion to sparse added
    if (issparse(compTracks(iTrack).tracksCoordAmpCG))        
        aggregStateMat(isnan(aggregStateMat)) = 0;    
        compTracks(iTrack).aggregState = sparse(aggregStateMat);
        %Also converting to sparse the original line below        
        aggregState = aggregStateDef(:,1+doubleFreq:(1+doubleFreq):end);
        aggregState(isnan(aggregState)) = 0;
        compTracksDef(iTrack).aggregState = sparse(aggregState);        
    else    
        compTracks(iTrack).aggregState = aggregStateMat;
        compTracksDef(iTrack).aggregState = aggregStateDef(:,1+doubleFreq:(1+doubleFreq):end);
    end

end %(for iTrack = 1 : numTracks)

%store results in output structure
compTracksOut = struct('defaultFormatTracks',compTracksDef,'alternativeFormatTracks',...
    compTracks);

%% ~~~ the end ~~~

end



