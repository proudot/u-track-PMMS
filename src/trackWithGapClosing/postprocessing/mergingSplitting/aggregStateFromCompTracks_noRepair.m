function [compTracksOut,segmentStat] = aggregStateFromCompTracks_noRepair(compTracks,intensityInfo)
%AGGREGSTATEFROMCOMPTRACKS_NOREPAIR recovers particle aggregation states 
%from compound tracks and does not repair errors in the recoverd 
%aggregation states (segment sizes). To get repaired sizes, use the
%function aggregationStateFromCompTracks_new.
%
%SYNOPSIS [compTracks,segmenetStat] = aggregStateFromCompTracks(compTracks,intensityInfo)
%
%INPUT  compTracks   : Compound tracks, in the format of tracksFinal as
%                      output by trackCloseGapsKalman.
%       intensityInfo: Row vector with unit intensity mean and standard
%                      deviation (e.g. the intensity of a single
%                      fluorophore labeling a single receptor).
%
%OUTPUT compTracks   : -Structure with the 2 fields "defaultFormatTracks" and
%                       "alternativeFormatTracks". 
%                      -Both contain the fields "tracksFeatIndxCG",
%                       "tracksCoordAmpCG", "seqOfEvents" and "aggregState".
%                      -"alternativeFormatTracks" also contains the field
%                       "alt2defSegmentCorrespond".
%                      -"defaultFormatTracks" is the format of the output of
%                       "trackCloseGapsKalman". 
%                      -"alternativeFormatTracks" is the format generated by
%                       the function "convFormatDefault2Alt", where tracks
%                       do not continue through merges and splits, but a
%                       merge consists of 2 track segments mergng to form a
%                       3rd segment, and a split consists of 1 track segment
%                       splitting into 2 different segments. 
%                      -The field "aggregState" has the same dimensions as
%                       "tracksFeatIndxCG", and indicates the estimated
%                       number of units (e.g. receptors) within each
%                       detected particle/feature.
%
%       segmentStat:    a struct with with the following fields detailing
%                       segment stats and size errors:
%                       1) intSizeErr:  IDs of segments with intensity size
%                       errors
%                       2) eveSizeErr:  IDs of segments with size errors as
%                       determined from events
%                       3) notRepIntSizeErr:  indicates segments whose
%                       intensity size errors were not repaired, when
%                       repairing - [] here.
%                       4) finalNotRepIntSizeErr:  final list of segments 
%                       whose intensity size errors were not repaired, when
%                       repairing - [] here.
%                       5) notRepEveSizeErr:  indicates segments whose
%                       event size errors were not repaired, when
%                       repairing - [] here.
%                       6) numInitSegs: number of initial segments
%                       7) numInitSegs: total number of segments
%                       8) numSplits: total number of split events
%                       9) numMerges: total number of merge events
%
%NOTE:  This function is a modification of the original function where
%processSegmentEvents has been added to process the segment merging and
%splitting events. The size determined for some of the segments will be
%incorrect. In aggregStateFromCompTracks_new, repairSizeFromIntensity and 
%repairSizeFromEvents are used to repair these inaccuracies.
%
%Khuloud Jaqaman, February 2009
%       Modified, January 2013, Robel Yirdaw
%       Modified, 12/12/14, Robel Yirdaw
%

%% Input

%assign default intensityInfo if not input
if nargin < 2 || isempty(intensityInfo)
    intensityInfo = [];
else
    %if unit intensity is input, construct vector of integer multiples of
    %mean unit intensity
    multUnitAmp = intensityInfo(1)*(1:100)';
end

%get number of compound tracks
numTracks = length(compTracks);

%convert tracks from default format (output of trackCloseGapsKalman) to
%alternative format where there is no track continuation through a merge or
%a split
compTracksDef = compTracks;
compTracks = convTrackFormatDefault2Alt(compTracksDef);

%Intitialize segment statistics struct
segmentStat(numTracks,1) = struct('intSizeErr','','eveSizeErr','','notRepIntSizeErr','',...
    'finalNotRepIntSizeErr','','notRepEveSizeErr','','numInitSegs','','numSegs','',...
    'numSplits','','numMerges','');


%% Calculation

%go over all compound tracks
for iTrack = 1 : numTracks
    
    %get this compound track's information
    seqOfEvents = compTracks(iTrack).seqOfEvents;
    tracksFeatIndx = compTracks(iTrack).tracksFeatIndxCG;
    tracksAmp = compTracks(iTrack).tracksCoordAmpCG(:,4:8:end);

    %determine whether track is sampled regularly or with doubled frequency
    doubleFreq = mod(seqOfEvents(1,1)*2,2)==1;

    %shift time in seqOfEvents to make the track start at frame 1 or 0.5
    %if sampling frequency is doubled
    seqOfEvents(:,1) = seqOfEvents(:,1) - seqOfEvents(1,1) + 1/(1+doubleFreq);

    %find all merging and splitting events
    msEvents = find(~isnan(seqOfEvents(:,4)));
    numMSEvents = length(msEvents);

    %initialize matrix storing aggregation state
    %     if isempty(intensityInfo) %if no information is given on the unit intensity
    %121214 - tracksFeatIndx must be converted to full if sparse. If not,
    %the function will hang on lines 115-116.    
    aggregStateMat = full(tracksFeatIndx); %initialize every branch with 1 unit        
    aggregStateMat = double((aggregStateMat ~= 0));
    aggregStateMat(aggregStateMat==0) = NaN;
    %     else %if there is unit intensity information
    %
    %     end

    %if this track does not exhibit any merges or splits, and there is unit
    %intensity information ...
    if numMSEvents == 0 && ~isempty(intensityInfo)
        
        %get this track's average intensity
        meanAmp = nanmean(tracksAmp);
        
        %subtract the integer multiples of the unit intensity from the
        %track's mean intensity
        meanAmpMinusMultUnitAmp = abs(meanAmp - multUnitAmp);
        
        %determine integer multiple yielding smallest difference
        intMult = find(meanAmpMinusMultUnitAmp==min(meanAmpMinusMultUnitAmp));
        
        %assign this value to the aggregation state of this track
        aggregStateMat = aggregStateMat * intMult;
        
    end %(if numMSEvents == 0)
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    if (numMSEvents ~= 0)
        
        numSegments = length(tracksAmp(:,1));
        segmentSet = NaN(numSegments,10);
        segmentSet(:,9) = 1;
        %Save segments with error in intentsity and event sizes
        segmentErr = {NaN(numSegments,1) NaN(numSegments,2)};

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %121214
        %Modified to now determine initSegs a segment that is created at
        %any point during the simulation/data acquistion time, instead of
        %segments present ONLY at frame 1.  This is done to accomodate
        %experimental data which can have segments appear anytime during
        %data acquisition.
        %initSegs = seqOfEvents(((seqOfEvents(:,1) == 1) & isnan(seqOfEvents(:,4))),3);
        initSegs = seqOfEvents(((seqOfEvents(:,2) == 1) & isnan(seqOfEvents(:,4))),3);
        numInitSegs = length(initSegs);   
        
        numSplitEvents = sum(~isnan(seqOfEvents(:,4)) & (seqOfEvents(:,2) == 1))/2;
        numMergeEvents = sum(~isnan(seqOfEvents(:,4)) & (seqOfEvents(:,2) == 2))/2;
        
        fprintf('\nNumber of starting segments is %d.',numInitSegs);
        fprintf('\nNumber of events is %d (%d splits, %d merges).',numMSEvents/2,...
            numSplitEvents,numMergeEvents);
        fprintf('\nNumber of segments is %d.',numSegments);        

        %fprintf('\n\nContinue...\n');
        %pause;
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %Begin processing segments
        %102313
        %Track number of recurssive calls
        callCount = 1;
        for initSegsIter=1:numInitSegs
            [segmentSet,segmentErr,callCount] = processSegmentEvents(NaN,initSegs(initSegsIter),...
                segmentSet,segmentErr,seqOfEvents,tracksAmp,intensityInfo,callCount);
        end
        %Number of segments with size errors
        segIntSizeErrCount = sum(~isnan(segmentErr{1}));
        %Trim NaNs
        segmentErr{1}(segIntSizeErrCount+1:end) = [];  
        fprintf('\n');
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
        %For each segment, write final values to aggregStateMat.
        %aggregState is initialized with 1s and NaNs. To simplify writing
        %of final values, find those segments whose sizes are > 1 and just
        %update those.
        
        segmentsWithSizeGT1 = find(segmentSet(:,8) > 1);        
        numEventSizeLarger = 0;
        for segIter=1:(length(segmentsWithSizeGT1))
            tempSegID = segmentsWithSizeGT1(segIter);
            aggregStateMat(tempSegID,~isnan(aggregStateMat(tempSegID,:))) = ...
                segmentSet(tempSegID,8);
            if ((segmentSet(tempSegID,9) > segmentSet(tempSegID,8)) )
                fprintf('\nEvent size > intensity size for segment %d. ',...
                    tempSegID);
                numEventSizeLarger = numEventSizeLarger + 1;
            end
        end
        if (numEventSizeLarger == 0)
            fprintf('\nAll event sizes <= intensity sizes.');
        end
        
        fprintf('\n');
        %fprintf('\n\nContinue...\n');
        %pause;
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %After construction, view and compare amplitudes from intensity and
        %events.    
        %{
        if (numSegments < 200)
            fprintf('\nDrawing %d segments.\n',numSegments);
            nodeIDs = cell(numSegments,1);
            for segIter=1:numSegments
                nodeIDs{segIter} = sprintf('Seg. %d, Amp=%g, Int. size=%d, Eve. size=%d',segIter,...
                    segmentSet(segIter,7),segmentSet(segIter,8),segmentSet(segIter,9));
            end      
            %Use bioGraphPlot to plot segments    
            [~,bgh] = bioGraphPlot_MergeSplitEvents(seqOfEvents,nodeIDs);
            %Adjust colors based on types of size errors
            set(bgh.Nodes,'Color',[.5 .9 1]);
            if (segIntSizeErrCount > 0)
                set(bgh.Nodes(([segmentErr{:,1}])),'Color',[0.9 0.3 0.6]);
            end
            if (segEveSizeErrCount > 0)
                set(bgh.Nodes([segmentErr{:,2}]),'Color',[0.5 0.5 0.8]);
                set(bgh.Nodes(intersect([segmentErr{:,1}],[segmentErr{:,2}])),...
                    'LineColor',[1 0 0],'LineWidth',2);
            end
        end
        %}

        %Prep return variable   
        segmentStat(iTrack).intSizeErr = segmentErr{1}(:);
        segmentStat(iTrack).eveSizeErr = segmentErr{2}(:);
        segmentStat(iTrack).notRepIntSizeErr = [];
        segmentStat(iTrack).finalNotRepIntSizeErr = [];
        segmentStat(iTrack).notRepEveSizeErr = [];
        segmentStat(iTrack).numInitSegs = numInitSegs;
        segmentStat(iTrack).numSegs = numSegments;
        segmentStat(iTrack).numSplits = numSplitEvents;
        segmentStat(iTrack).numMerges = numMergeEvents;
      
    end %numMSEvents ~= 0
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %store aggregation state matrix in compound tracks structure with
    %"alternative format"
    %121214 - moved below for sparse conversion if necessary
    %compTracks(iTrack).aggregState = aggregStateMat;

    %store aggregation state matrix in compound tracks structure with
    %"default format" ...

    %get number of segments in default format
    numSegmentsDef = size(compTracksDef(iTrack).tracksFeatIndxCG,1);

    %copy aggregation state matrix
    aggregStateDef = aggregStateMat(1:numSegmentsDef,:);

    %copy out segment correspondence array
    segmentCorrespond = compTracks(iTrack).alt2defSegmentCorrespond;

    %go over additional segments in alternative format and store their
    %aggregation state in the original segment location
    for iSegment = 1 : size(segmentCorrespond,1)
        segmentNew = segmentCorrespond(iSegment,1);
        segmentOld = segmentCorrespond(iSegment,2);
        aggregStateDef(segmentOld,:) = max([aggregStateDef(segmentOld,:);...
            aggregStateMat(segmentNew,:)]);
    end
    
    %121214 - moved from above with conversion to sparse added
    if (issparse(compTracks(iTrack).tracksCoordAmpCG))        
        aggregStateMat(isnan(aggregStateMat)) = 0;    
        compTracks(iTrack).aggregState = sparse(aggregStateMat);
        %Also converting to sparse the original line below        
        aggregState = aggregStateDef(:,1+doubleFreq:(1+doubleFreq):end);
        aggregState(isnan(aggregState)) = 0;
        compTracksDef(iTrack).aggregState = sparse(aggregState);        
    else    
        compTracks(iTrack).aggregState = aggregStateMat;
        compTracksDef(iTrack).aggregState = aggregStateDef(:,1+doubleFreq:(1+doubleFreq):end);
    end
    

end %(for iTrack = 1 : numTracks)

%store results in output structure
compTracksOut = struct('defaultFormatTracks',compTracksDef,'alternativeFormatTracks',...
    compTracks);

%% ~~~ the end ~~~

end



